<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bitwise in JS</title>
  </head>

  <body>
    <h2>Bits</h2>
    <p>
      Bit is made from 2 words, Binary and digit. B is taken from Binary and "it" is taken from digit. دوہرا · ثنائی ·
      مثنیٰ · مزدوج · جوڑے دار · کسی شے یا نظام میں ہر دو میں سے ایک منتخب کر سکنے کی صلاحیت رکھنے والا · بائینری.
    </p>
    <p>
      <b> Whole Number : </b> Any positive number that does not include a fractional or decimal part. This means that,
      for example, the numbers 0, 1, 2, 3, 4, 5, 6, and 7 are all whole numbers.
    </p>
    <h2>Decimal Numbers</h2>
    <p>The word decimal comes from the Latin word 'decimus' that means "tenth part"</p>
    <p>(1 out of 10 parts) 1/10 is fraction and 0.1 is decimal.</p>

    <pre>
    0.1
    0 is whole number;
    . is decimal point;
    1 is fractional part
  </pre
    >
    <p><b> Key Fact</b> A decimal number is a fraction with a denominator of 10, 100 and 1000.</p>
    <p>3/10 = 0.3 and 7/10 = 0.7</p>
    <h2>Hunderedths in decimal</h2>
    <p>If we eat one part out of 100, so we will write 1/100 in fraction and 0.01 in decimal. 77/100 = 0.77</p>
    <h2>Thousandths</h2>
    <p>1/1000 = 0.001</p>

    <h2>Base 10 decimals numbers</h2>

    <p>
      Base 10 decimals refer to the standard number system used in everyday life, also known as the
      <b> decimal system. </b> It is called <b> base 10 </b> because it is based on ten digits: 0, 1, 2, 3, 4, 5, 6, 7,
      8, and 9. Each digit in this numbers represents a different power of 10, depending on its position.
    </p>
    <p>For example, in the number 345.67:</p>
    <ul>
      <li>The digit 3 is in the hundreds place, so it represents 3 * 10 <sup>2</sup> = 300</li>
      <li>The digit 4 is in the tens place, so it represents 4 * 10 <sup> 1</sup> = 40</li>
      <li>The digit 5 is in the ones place, so it represents 5 * 10 <sup>0</sup> = 5</li>
      <li>The digit 6 is in the tenths place, so it represents 6 * 10 <sup> -1</sup> = 0.6</li>
      <li>The digit 7 is in the hundredths place, so it represents 7 * 10 <sup> -2</sup> = 0.07</li>
    </ul>
    <p><b> Together </b> 300 + 40 + 5 + 0.6 + 0.07 = 345.67</p>

    <p>The system is widely used because it matches the way humans typically count using ten fingers</p>

    <h2>General Rule for Negative Exponents</h2>
    <p>For any number: a<sup>-n</sup></p>
    <pre>
               a<sup>n</sup> = 1/a<sup>n</sup> (a-n = 1/an)
               </pre
    >
    <p>So for 10<sup>-2</sup>=1/10 * 10 ; = 1/100 ; = 0.01 :</p>
    <pre>
                10<sup>-3</sup> = 1/10*10*10 = 0.001
               </pre
    >

    <h2>Usage in JavaScript</h2>
    <p>
      You can calculate this in JavaScript using the Math.pow() function or the Exponentiation (Ex-poh-nen-shee-ay-shun)
      operator **:
    </p>
    <p>
      The exponentiation operator (**) in JavaScript is used to raise a number to the power of another number. It is
      equivalent to using Math.pow().
    </p>
    <script>
      console.log(Math.pow(10, 2));
      console.log(10 ** -2); // Output: 0.01
    </script>
    <pre>
      A negative exponent means reciprocal, so:
      10<sup>-2</sup> = 1/ 10<sup>-2</sup> = 1/100 = 0.01
    </pre>
    <h2>Place Value of digits in decimal</h2>
    <p>Here's how place values work on both sides of the decimal point</p>
    <p>
      <b>Left of the Decimal (Whole Numbers) :</b> The place value starts from ones (10⁰) and increases by powers of 10
      as you move left.
    </p>
    <pre>
1 → Ones (10⁰ = 1)
         10 → Tens (10¹ = 10)
         100 → Hundreds (10² = 100)
         1000 → Thousands (10³ = 1000)</pre
    >
    <p>
      <b> Right of the Decimal (Decimal Fractions) :</b>The place value starts from tenths (10⁻¹) and decreases by
      powers of 10 as you move right.
    </p>
    <pre>
          0.1 → Tenths (10⁻¹ = 1/10 = 0.1)
          0.01 → Hundredths (10⁻² = 1/100 = 0.01)
          0.001 → Thousandths (10⁻³ = 1/1000 = 0.001)
         </pre
    >
    <pre>
          For the number 123.456, the place values are:

  Digit	       Place Value
   1     	Hundreds (10² = 100)
   2     	Tens (10¹ = 10)
   3     	Ones (10⁰ = 1)
   4     	Tenths (10⁻¹ = 0.1)
   5     	Hundredths (10⁻² = 0.01)
   6     	Thousandths (10⁻³ = 0.001)
         </pre
    >

    <h2>Bitwise in JS</h2>
    <p>
      Bitwise refers to operations or manipulations of data at the level of individual bits, which are the smallest
      units of data in computing, either 0 or 1. 0 for off and 1 for on. Bitwise operations are fundamental in low-level
      programming and are used to manipulate bits directly, usually for performance optimization, encryption, and other
      specialized tasks. In JavaScript (and many other languages), there are several bitwise operators that allow you to
      work with the bits of binary numbers.
    </p>
    <pre>
  00
  01
  10
  11
</pre
    >
    <h4>Bit and Byte</h4>
    <p>In general computing, the terms bit and byte represent different units of data.</p>
    <h4>Bit</h4>
    <ul>
      <li>A bit is the smallest unit of data in computing.</li>
      <li>1 bit: A single binary digit (0 or 1)</li>
      <li>It can have one of two values: 0 or 1.</li>
      <li>A bit represents a single binary digit.</li>
      <li><b> Data Range </b> Can store 2 values (0, 1)</li>
      <li>8 bits = 1 byte ..... 10101010 (8 bits = 1 byte)</li>
      <li>If we extend your 2-bit values to 8 bits, they would look like:</li>
      <pre>
        00000000  (0 in decimal)
        00000001  (1 in decimal)
        00000010  (2 in decimal)
        00000011  (3 in decimal)
       </pre
      >
      <li>1 Kilobyte (KB) = 1024 Bytes</li>
      <li>1 Megabyte (MB) = 1024 KB</li>
      <li>Giga</li>
      <li>Tera</li>
      <li>Peta</li>
      <li>Exa</li>
      <li>Zetta</li>
      <li>Yotta</li>
      <li>Bronto</li>
      <li>Geop</li>
    </ul>

    <h4>Byte</h4>
    <ul>
      <li>A byte is a collection of 8 bits.</li>
      <li>It is the standard unit used to measure data size.</li>
      <li>
        A byte can represent 256 different values (from 0 to 255 in decimal, or 00000000 to 11111111(0 to 255) in
        binary).
      </li>
      <li><b> Data Range </b> Can store 256 values (0 to 255)</li>
    </ul>

    <h3>Why do we use 8 bit to store numbers</h3>
    <ul>
      <li>1 bit = 2 characters (0,1)</li>
      <li>2 bits = 4 characters (00, 11, 01, 10)</li>
      <li>3 bits = 8 characters</li>
      <li>4 bits = 16 characters</li>
      <li>5 bits = 32 characters</li>
      <li>6 bits = 64 characters</li>
      <li>7 bits = 128 characters</li>
      <li>8 bits = 256 characters</li>
    </ul>

    <h2>How does 11111111 become 255?</h2>
    <p>The number 11111111 is an 8-bit binary number, meaning it has 8 digits, each representing a power of 2.</p>
    <p>
      Binary to Decimal Conversion: Each bit in an 8-bit binary number represents a power of 2, starting from 2<sup
        >0</sup
      >
      on the right:
    </p>
    <pre>
      Binary      Power of 2           Value 
      1           2<sup>7</sup>                     128
      1           2<sup>6</sup>                      64
      1           2<sup>5</sup>                      32
      1           2<sup>4</sup>                      16
      1           2<sup>3</sup>                      8
      1           2<sup>2</sup>                      4
      1           2<sup>1</sup>                      2
      1           2<sup>0</sup>                      1
    </pre>
    <p>128+64+32+16+8+4+2+1=255</p>
    <p>So, 11111111 in binary is 255 in decimal.</p>
    <p>
      The statement 1 bit = 2 characters, 2 bits = 4 characters, 3 bits = 8 characters refers to the number of<b>
        unique combinations
      </b>
      or <b> patterns </b> that can be represented with a certain number of bits.
    </p>

    <h3>How This Works:</h3>
    <ul>
      <li>A bit is the smallest unit of data in a computer and can have two values: 0 or 1.</li>
      <li>As you increase the number of bits, the number of possible combinations of 0s and 1s grows exponentially.</li>
      <p>This follows the formula:</p>
      <p>Number of combinations = 2 <sup>number of bits </sup></p>
    </ul>
    <p>Let's break it down:</p>
    <h3>1 Bit :</h3>
    <ul>
      <dt>With 1 bit, you can only have 2 combinations:</dt>
      <dd>0</dd>
      <dd>1</dd>
      <dd>This means 1 bit can represent 2 unique characters.</dd>
    </ul>
    <h3>2 Bits :</h3>
    <ul>
      <dt>With 2 bits, you can have 4 combinations:</dt>
      <dd>00</dd>
      <dd>11</dd>
      <dd>01</dd>
      <dd>10</dd>
      <dd>This means 2 bits can represent 4 unique characters.</dd>
    </ul>
    <h3>3 Bits :</h3>
    <ul>
      <dt>With 3 bits, you can have 8 combinations:</dt>
      <dd>000</dd>
      <dd>001</dd>
      <dd>010</dd>
      <dd>011</dd>
      <dd>100</dd>
      <dd>101</dd>
      <dd>110</dd>
      <dd>111</dd>
      <dd>This means 3 bits can represent 8 unique characters.</dd>
    </ul>
    <h4>And So On</h4>
    <h3>Summary :</h3>
    <p>
      The number of unique characters or values that can be represented by a set number of bits increases exponentially
      as you add more bits. Each additional bit doubles the number of possible combinations:
    </p>
    <p>2 <sup>1 </sup> = 2 , 2 <sup> 2</sup>= 4 , 2 <sup> 3 </sup> = 8, 2 <sup> 4 </sup> = 16 ..... And so on</p>

    <h2>numbers to binary</h2>
    <h3>How to Get 65 in Binary:</h3>
    <p>Let us see step-by-step how to convert 65 into binary:</p>

    <ol>
      <li>Step 1: Start with 65 (decimal).</li>
      <li>Step 2: Divide by 2, and keep track of the remainders:</li>
    </ol>
    <ul>
      <li>65 ÷ 2 = 32 remainder 1 (this is the least significant bit).</li>
      <li>32 ÷ 2 = 16 remainder 0.</li>
      <li>16 ÷ 2 = 8 remainder 0.</li>
      <li>8 ÷ 2 = 4 remainder 0.</li>
      <li>4 ÷ 2 = 2 remainder 0.</li>
      <li>2 ÷ 2 = 1 remainder 0.</li>
      <li>1 ÷ 2 = 0 remainder 1 (this is the most significant bit).</li>
    </ul>
    <p><b> Step 3 </b>: Read the remainders in reverse order:</p>
    <p>Starting from the last remainder to the first, we get 1000001, or in 8-bit format, 01000001.</p>
    <p>Thus, the binary form of 65 is 1000001.</p>

    <p>Pic Of Decimal To Binary is below</p>
    <img src="jsBitwise.png" alt="BinaryPic" width="300px" height="200px" />
    <p>Another Pic</p>
    <img src="jsBitwise2.png" alt="BinaryPic" width="300px" height="200px" />
    <p>
      In binary division, the result of <b>1 ÷ 2 = 0 remainder 1 </b> is based on how division works in base-2 (binary)
      rather than base-10 (decimal). Let us break it down.
    </p>
    <h3>Understanding the Division:</h3>
    <p>
      In binary, 1 represents a single unit, and 2 in binary is represented as 10 (the base-2 number for the decimal
      number 2).
    </p>
    <h3>Step-by-Step Binary Division:</h3>
    <p>We want to divide 1 by 2:</p>
    <ol>
      <li>How many times does 2 go into 1?</li>

      <ul>
        <li>In binary terms, 2 is bigger than 1, so 2 goes into 1 zero times.</li>
        <li>This is why the quotient is 0.</li>
      </ul>
      <li>What is the remainder?</li>
      <ul>
        <li>Since 2 can not fit into 1, the remainder is still 1 (the original number).</li>
        <li>This remainder is written as 1.</li>
      </ul>
    </ol>

    <h4>Result in Binary:</h4>
    <p>Thus, when you divide 1 by 2 in binary:</p>
    <ul>
      <li>The quotient is 0</li>
      <li>The remainder is 1.</li>
    </ul>
    <p>This is expressed as:</p>
    <p>1÷2=0 remainder 1</p>
    <p>
      In binary, the quotient 0 means that the division does not produce a whole number, but the remainder 1 shows that
      1 unit is left over after the division attempt.
    </p>

    <h3>How It's Similar to Decimal:</h3>
    <p>
      In decimal, when you divide 1 by 2, the result is 0.5, which means 0 full twos fit into 1, and you have half (0.5)
      left over.
    </p>
    <p>
      In binary, since we do not have fractional numbers in standard binary division, we only express the remainder (in
      this case, 1) instead of a decimal fraction.
    </p>

    <h3>JavaScript Uses 32 bits Bitwise Operands</h3>
    <p>
      "32-bit bitwise" refers to operations that manipulate the individual bits of 32-bit binary numbers. Here's a
      breakdown of what this means:
    </p>
    <h4>What is 32 Bits?</h4>
    <ul>
      <li>32 bits means the number is represented using 32 binary digits (0s and 1s).</li>
      <li>
        In terms of integer values, this allows for a range of values from -2,147,483,648 to 2,147,483,647 when using
        signed integers (two's complement).
      </li>
    </ul>

    <h3>Bitwise Operations</h3>
    <p>
      Bitwise operations work directly on the binary representation of numbers. Common bitwise operators include: <br />

      1: <b> AND (&): </b> Compares each bit of two numbers; results in 1 if both bits are 1, otherwise 0. <br />
      Example: 5 & 3 results in 1 (binary 0001). <br />

      2: <b> OR (|): </b> Results in 1 if at least one of the bits is 1. <br />
      Example: 5 | 3 results in 7 (binary 0111). <br />

      3: <b> XOR (^): </b> Results in 1 if the bits are different. <br />
      Example: 5 ^ 3 results in 6 (binary 0110).<br />

      4: <b> NOT (~): </b> Inverts the bits. <br />
      Example: ~5 results in -6 (in binary, all bits flipped). <br />

      5: <b> Left Shift ( &lt; &lt; ): </b> Shifts bits to the left, filling in with zeros. Each shift to the left
      effectively multiplies the number by 2. <br />
      Example: 5 &lt; &lt; 1 results in 10 (binary 1010). <br />

      6: <b> Right Shift (>>): </b> Shifts bits to the right. For signed numbers, it preserves the sign bit (the
      leftmost bit). <br />
      Example: 5 >> 1 results in 2 (binary 0010). <br />

      7: <b> Unsigned Right Shift (>>>): </b> Shifts bits to the right without preserving the sign bit. <br />
      Example: -1 >>> 1 results in 2147483647.
    </p>
    <br />

    <h3>Summary :</h3>
    <p>
      When you perform bitwise operations in a language like JavaScript, the numbers are treated as 32-bit integers.
      These operations allow you to manipulate the individual bits of numbers directly, which can be useful for tasks
      like setting flags, manipulating binary data, or optimizing performance in certain algorithms.
    </p>
  </body>
</html>
